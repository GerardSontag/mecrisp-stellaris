\ ymodem
\ **************
\ xmodem block org proto
\  +---+-----+------+-----------------+----+
\  |SOH|BLKNR|#BLKNR|DATA1 ... DATA128|CSUM|
\  +---+-----+------+-----------------+----+
\  SOH - start of head <$01>
\  BLKNR - Blocknumber starts at <$01> wraps at <$FF> to <$00> not to 1
\  #BLKNR - <$FF - BLKNR>
\
\
\

$01 constant <SOH> \ start of 128 byte block
$02 constant <STX> \ start of 1024 byte block
$04 constant <EOT>
$06 constant <ACK>
$15 constant <NAK>
$18 constant <CAN>
$43 constant <C>

\ crc calculation functions
decimal
: crc1 ( crc c -- crc ) \ update the xmodem crc looped version
  8 lshift   ( crc  c<<8 )
  xor        ( crc' )
  8 0 do
    2*  dup $10000 and ( crc' f )
    if  $1021 xor      ( crc' )
    then
  loop
  $ffff and
  ;

decimal
: crc2 ( crc c -- crc )     \ update xmodem crc
   swap dup                    ( c crc crc )
   $8 rshift swap $8 lshift OR ( c crc )
   XOR                         ( crc )
   dup $ff and 4 rshift xor
   dup $0c lshift xor
   dup $ff and 5 lshift xor
   $ffff and
   ;

: test-crc-data ( crc -- )
  $100 0 do
    i 2dup ( crc c crc c )
    2dup ( crc c crc c crc c )
    crc1 ( crc c crc c crc1 )
    -rot  ( crc c crc1 crc c )
    crc2 ( crc c crc1 crc2 )
    \ ." test " .s
    <> if ." error char: " . ." crc: " dup . cr
    else drop
    then
  loop
  drop
;

: test-crc
  $10000 0 do
    i $3FF and
    0= if
       ." Run " i . cr
    then
    i test-crc-data
  loop
;

$E5CC constant CRC_TEST_RESULT
$FFFF constant CRC_TEST_START
: test-crc-0x1021
  s" 123456789" ( cadr len -- )
;

: perform-crc-test ( fkt-adr -- f )
  CRC_TEST_START  ( f -- f crc )
  test-crc-0x1021 ( f crc -- f crc cstring len ) .s
  over + swap     ( f crc cend cstart ) .s
  do              ( f crc )
    i c@        ( f crc c )
    2 pick      ( f crc c f ) .s
    execute     ( f crc )
  loop
  swap drop       ( crc ) .s
  CRC_TEST_RESULT = dup
  if   ." Test ok " cr
  else ." Test failed " cr
  then
;

: test-crc1
  ['] crc1 perform-crc-test
  drop ;

: test-crc2
  ['] crc2 perform-crc-test
  drop ;

: update-csum ( csum c -- csum ) \ 8 bit checksum
  + $ff and
  ;

: xmit-crc ( adr len -- ) \ xmodem transmit using crc
;

: emit-blk-nr ( blk -- )
  dup emit not $FF and emit
;

decimal
16000000 variable SYS_HZ

: ms ( ms -- u )           \ calculate milliseconds
  SYS_HZ @ 1000 u*/        \  use SYS_HZ as time base
;

: seconds ( s -- d )
  SYS_HZ @ m*
;

: wait-long ( tl th -- )         \ wait for a long time - depends on timer frequency
  systick-run ( tl th -- )
  STK_VAL @ ( tl th  t1 -- )
  begin
    STK_VAL @ ( tl th t1 t2 -- )
    tuck      ( tl th t2 t1 t2 )
    -         ( tl th t2 dt )
    dup 0<    ( tl th t2 dt f )
    if        ( tl th t2 dt )
      STK_LOAD @ 1+ +
    then      ( tl th t2 dt )
    2swap     ( t2 dt tl th )
    rot 0     ( t2 tl th dt 0 )
    d-        ( t2 tl th )
    2dup      ( t2 tl th tl th ) \ 2dup d. cr
    d0<       ( t2 tl th f )
    >r rot r> ( tl th t2 f )
  until       ( tl th t2 )
  2drop drop
;

: wait ( t -- )                 \ wait for a certain amount of systick timer ticks
  systick-run ( t -- )
  STK_VAL @ ( t t1 -- )
  begin
    STK_VAL @ ( t t1 t2 -- )
    tuck      ( t t2 t1 t2 )
    -         ( t t2 dt )
    dup 0<    ( t t2 dt f )
    if        ( t t2 dt )
      STK_LOAD @ 1+ +
    then      ( t t2 dt )
    .s
    rot - negate ( t2 t )
    tuck      ( t t2 t )
  0< until       ( t t2 )
  2drop
;
$80000000 variable dtmax
$7FFFFFFF variable dtmin

: stat ( v -- )
  dup dtmax @ ( v v dtmax )
  > if ( v )
    dup dtmax ! ( v )
  then ( v )
  dup ( v v )
  dtmin @ ( v v dtmin )
  < if ( v )
    dtmin ! ( -- )
  else
    drop  ( -- )
  then
;

\ perform a single time step
\ t is the remaining time
\ t1 is the timestamp related to the time t
\ must be invoked during within one complete timer period
: time-step      ( t1 t -- t2 t')
  swap           ( t t1 )
  STK_VAL @      ( t t1 t2 )
  tuck           ( t t2 t1 t2 )
  -              ( t t2 dt )               \ dt = 0 means timer not yet increased for low sysclock frequency
  dup 0<         ( t t2 dt f )             \ handle timer wrap around
  STK_LOAD @ 1+  ( t t2 dt f STK_LOAD@++ ) \ add timer period when wrap to dt
  and +          ( t t2 dt)                \ only add timer period when dt is negative -> wrap around
  rot            ( t2 dt t )
  - negate       ( t2 t' )
;

: get-stk-val
  STK_VAL @
;

\ busy wait for keypress with timeout in systick timer units
: wait-key           ( t -- key|-1 )           \ wait for keypress with timeout return keykode or -1 if timeout
  systick-run        ( t       )
  STK_VAL @          ( t t1    )
  swap               ( t1 t    )
  begin
    time-step        ( t2  t   ) 
    dup 0< if        ( t2  t   )
      2drop -1 -1    ( -1 -1   )         \ timeout
    else             ( t2  t   )
      key?           ( t2  t f )
      if             ( t2  t   )         \ keypress detected
        2drop key -1 ( key -1  )         \ adjust stack for exit
      else 0         ( t2 t 0  )         \ no key next loop
      then           ( key -1 | t2 t 0 ) 
    then             ( key -1 | t2 t 0 )
  until              ( key    | t2 t   )
;

\ decimal 320000000 cr hex wait-key

: send-block-csum ( adr len -- f )
  over + swap     ( end start )
  0 -rot          ( csum end start )
  do              ( csum )
    i c@          ( csum c )
    dup emit      ( csum c )
    update-csum   ( csum )
  loop
  emit            ( )
  key <ack> =
;

: xmit-csum-blk ( adr len blk -- )
  <SOH> emit             ( adr len blk )
  dup emit-blk-nr        ( adr len blk )
  -rot                   ( blk adr len )
  2dup                   ( blk adr len adr len )
  send-block-csum        ( blk adr len f )
  \ TODO
;

: xmit-csum ( adr len -- ) \ xmodem transmit using checksum
<SOH> emit
;


: xmit ( adr len -- ) \ xmodem transmit
  key
  case
  <C>   of xmit-crc  endof
  <nak> of xmit-csum endof
  endcase
  ;
