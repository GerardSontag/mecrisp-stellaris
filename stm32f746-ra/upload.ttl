; ;
;    tera term mecrisp-stellaris forth upload helper
;    Copyright (C) 2015, 2016  Jean Jonethal
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see <http://www.gnu.org/licenses/>.

; small upload macro for uploading forth source via tera term tested with version 4.88
; Tera Term website http://ttssh2.osdn.jp/index.html.en
; tera term supports call stack up to 10 levels on my laptop so using iterative approach here

; upload source file to target line by line and waits for "ok." after transmission of line.
; supports nesting include with pathname
; support nesting 'require' single include with pathname
; line containing include or require directive is not sent to target
; max source line length is 511
; include path\filename.ext

; example project.txt :
; include dump.txt
; include ..\common\disassembler-m3.txt
; include demo2.fth

; TODO: find better approach for path handling
;       currently upload words for letter assigned paths only
;       UNC naming is not supported
; test path handling

; global definitions
DEFAULT_CONNECTION = '/C=7'
MAXLEVEL        =  20                         ; max nesting level up to 65536 levels might be supported by tera term
MAX_LINE_LENGTH = 511                         ; max string/line length supported by tera term
INCLUDE_PATTERN = "include\s+([\.\w/:\\-]+)"  ; this pattern marks our include file
REQUIRE_PATTERN = "require\s+([\.\w/:\\-]+)"  ; this pattern marks our require file
SOURCE_PATTERN  = "^([^\\]+)"                 ; skip line comments
timeout         = 5                           ; you might tune this for longer response times
PATH_SEP        = "\"                         ; path separator "\" in windows os
regexoption "IGNORECASE"                      ; ignore lower uppercase for "include" and "require"
mtimeout        = 500                         ; wait 500 ms for "ok." response
infilehandle    =  -1                         ; current file handle
fname           = ""                          ; current filename
newfileHandle   =  -1                         ; store the new file handle
; parameter stack                             ; stack rised upwards
level = 1                                     ; current include level
intdim cfh MAXLEVEL                           ; file handle stack
intdim clp MAXLEVEL                           ; line position stack - unused at the moment
strdim cln MAXLEVEL                           ; line stack - unused at the moment
strdim cfn MAXLEVEL                           ; filename stack
strdim cpa MAXLEVEL                           ; directory stack - maintain directory
MAX_INCLUDE_HIST = 1000                       ; maximum number of include files to memoize
strdim rfnbase MAX_INCLUDE_HIST               ; memoize up MAX_INCLUDE_HIST include file names in lower case
strdim rfndir MAX_INCLUDE_HIST                ; memoize up MAX_INCLUDE_HIST include file directories
rfnbaseSize      = 0                          ; current size of include file list

; check for macro parameter
if paramcnt = 2 then                          ; if there is a macro parameter
	fname = param2                              ; use it as input file name
endif
strlen fname 
if result = 0 then                            ; if there is no valid parameter
	filenamebox "select file" 0                 ; open file dialog for selection 
	fname = inputstr
  messagebox fname "opened"
endif

; when invoked as standalone macro - close running instances of teraterm before.
testlink                                      ; check if we are inside teraterm
if result  < 2 then                           ; we are not in connected state
  connect DEFAULT_CONNECTION                  ; reopen teraterm instance and 
  callmenu 50200                              ; exit all instances
  closett                                     ; avoid exit query
  connect DEFAULT_CONNECTION                  ; restart teraterm connection 
endif

dirname prjdir fname                          ; setup current directory to fname
setdir prjdir                                 ; set macrodir to directory
                                              ; containing file fname 

call uploading
goto ende

:uploading
  fileopen infilehandle fname 0 1
  if infilehandle <> -1 then                  ; if file open successful
    level = 1                                 ; we start at level 1
    cfn[level] = fname                        
    cfh[level] = infilehandle
    cpa[level] = prjdir
    while 1
      infilehandle = cfh[level]               ; update current file handle
      filereadln infilehandle line            ; get next line from this file
      if result = 0 then
        call processLine
      else                                    ; end of file
        call levelback                        ; close file, back one level
        if level < 1 then                     ; upper most file ended
          messagebox fname "Finished"         ; notify user 
          break
        endif
      endif
    endwhile
  endif
return

:levelback
; close file and switch to previous level

  fileclose infilehandle
  infilehandle = -1
  cfh[level]   = -1
  level        =  level - 1
  if level > 0 then                           ; back to previous level
    infilehandle = cfh[level]
    fname        = cfn[level]
    call absoluteFileName                     ; restore directory
  endif
return

:processLine                                    
; scan every line for include filename or send to target and wait for "ok."
; line contains current line to be scanned

  strmatch line INCLUDE_PATTERN               ; scan line for include pattern
  if result > 0 then
    fname = groupmatchstr1                    ; found new include line
    call includeFile
  else
    strmatch line REQUIRE_PATTERN
    if result > 0 then
      fname = groupmatchstr1                 ; found new require line
      call requireFile
    else
      call skipComment
      send line #10
      wait "ok."
    endif
  endif
return

:insertFileName
; insert fname to rfnbase
; insertPos - position where to insert filename
; fname - filename to insert
  int2str strPos insertPos
  ; messagebox strPos "insertFileName"
  if insertPos < 0 then     ; append
    insertPos = rfnbaseSize
  elseif insertPos > rfnbaseSize then ; append
    insertPos = rfnbaseSize
  endif
  if insertPos < rfnbaseSize then             ; make space for new filename
    for i rfnbaseSize insertPos+1
      rfnbase[i] = rfnbase[i-1]
    next
  endif
  tolower fnamelc fname
  rfnbase[insertPos] = fnamelc                ; insert new filename
  int2str strPos insertPos
  ; messagebox strPos "insertFileName at pos"
return

; "CCC"
; "BBB"  "BAA"
; "AAA"

:findInsertPos
; linear search in rfnbase for fname
; return new insert pos of fname in rfnbase or -1 if already exists
  tolower fnamelc fname
  pos = rfnbaseSize
  searchEnd = rfnbaseSize - 1
  if searchEnd < 0 then
    searchEnd = 0
  endif
  for i 0 searchEnd
    int2str istr i
    ; messagebox istr "findInsertPos"
    strcompare rfnbase[i] fnamelc 
    if result = 0 then
      pos = -1
      ; messagebox istr "findInsertPos found in rfnbase"
      break
    elseif result < 0 then
      pos = i
      break
    endif
  next
return

:tryAddFname
; try to add fname or skip if already exists
; pos return insert position or -1 if entry exists
  ; messagebox fname "tryAddFname"
  call findInsertPos
  if pos >= 0 then
    insertPos = pos
    call insertFileName
  else
    ; messagebox fname "tryAddFname exist"
  endif
return

:absoluteFileName
; make fname absolut
; change to directory of file for relative path resolution 
; return absolute fname 
  dirname dir fname
  basename bn fname
  setdir dir 
  getdir dir
  strconcat dir PATH_SEP
  strconcat dir bn
  fname = dir
  ; messagebox fname "absoluteFileName"
  tolower fnamelc fname
return


:requireFile
; check for reqired files
; keep track of all included and required files
  call absoluteFileName
  call tryAddFname
  if pos >= 0 then
    call openNewFile
  else
    fname = cfn[level]                        ; restore current filename
    call absoluteFileName                     ; and path context
  endif
return

:includeFile
; @param fname - contains filename
  ; messagebox fname "includeFile"
  call absoluteFileName                       ; convert fname to absolute name 
  call tryAddFname
  call openNewFile
return

:openNewFile
; start a new include level when open successfull
; fname contains new include filename
; notify user if failed to open included file
  ; messagebox fname "openNewFile"
  fileopen newfileHandle fname 0 1
  if newfileHandle <> -1 then                 ; new include file opened
    level        = level + 1
    infilehandle = newfileHandle
    cfn[level]   = fname
    cfh[level]   = infilehandle
  else
    ; messagebox fname "open failed"            ; notify user about failed file
  endif
return

:skipComment
; dont transfer comments
  strmatch line SOURCE_PATTERN                ; skip comments
  if result > 0 then
    line = groupmatchstr1
    strmatch line "^\s*+(.*?)\s*+$"           ; strip leading and trailing white
    line = groupmatchstr1                     ; spaces
  else
    line = ""
  endif
return


:ende
